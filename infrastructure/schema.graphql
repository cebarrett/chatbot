# GraphQL Schema for Chatbot AppSync API
# Authentication: OIDC (Clerk) for users, IAM for Lambda internal calls

# Input types
input SendMessageInput {
  requestId: String!
  provider: ChatProvider!
  messages: [ChatMessageInput!]!
  model: String
  imageSize: String       # "1024x1024", "1024x1536", "1536x1024"
  imageQuality: String    # "low", "medium", "high"
}

input ChatMessageInput {
  role: MessageRole!
  content: String!
}

input JudgeInput {
  judgeProvider: ChatProvider!
  originalPrompt: String!
  responseToJudge: String!
  respondingProvider: String!
  conversationHistory: [ChatMessageInput!]
  model: String
}

input JudgeFollowUpInput {
  judgeProvider: ChatProvider!
  originalPrompt: String!
  responseToJudge: String!
  respondingProvider: String!
  conversationHistory: [ChatMessageInput!]
  previousScore: Float!
  previousExplanation: String!
  previousProblems: [String!]!
  followUpQuestion: String!
  model: String
}

input CreateChatInput {
  chatId: String!
  title: String!
  providerId: String
}

input SaveMessageInput {
  chatId: String!
  messageId: String!
  role: MessageRole!
  content: String!
  timestamp: String!
  contentBlocks: AWSJSON  # Structured content with images
}

input UpdateMessageInput {
  chatId: String!
  messageId: String!
  content: String
  judgeRatings: AWSJSON
  timestamp: String!
}

input UpdateChatInput {
  chatId: String!
  title: String
  providerId: String
}

input DeleteMessageInput {
  chatId: String!
  messageId: String!
  timestamp: String!
}

input TranscribeAudioInput {
  audio: String!
  mimeType: String!
}

# Enums
enum ChatProvider {
  OPENAI
  ANTHROPIC
  GEMINI
  PERPLEXITY
  GROK
  GEMINI_IMAGE
  OPENAI_IMAGE
}

enum MessageRole {
  user
  assistant
  system
}

# Output types
type SendMessageResponse {
  requestId: String!
  status: String!
  message: String
}

type MessageChunk @aws_iam @aws_oidc {
  requestId: String!
  userId: String!
  chunk: String!
  done: Boolean!
  sequence: Int!
  error: String
}

type JudgeResponse {
  score: Float!
  explanation: String!
  problems: [String!]!
  judgeProvider: String!
}

type JudgeFollowUpResponse {
  answer: String!
  judgeProvider: String!
}

type ChatSummary @aws_oidc {
  chatId: String!
  title: String!
  providerId: String
  createdAt: String!
  updatedAt: String!
  messageCount: Int
}

type ChatDetail @aws_oidc {
  chatId: String!
  title: String!
  providerId: String
  createdAt: String!
  updatedAt: String!
  messages: [StoredMessage!]!
  nextToken: String
}

type StoredMessage @aws_oidc {
  messageId: String!
  role: MessageRole!
  content: String!
  timestamp: String!
  judgeRatings: AWSJSON
  contentBlocks: AWSJSON
}

type ChatListResult @aws_oidc {
  chats: [ChatSummary!]!
  nextToken: String
}

type DeleteChatResult @aws_oidc {
  chatId: String!
  success: Boolean!
}

type DeleteMessageResult @aws_oidc {
  messageId: String!
  success: Boolean!
}

type TranscriptionResult @aws_oidc {
  text: String!
  duration: Float
}

type UserPreferences @aws_oidc {
  preferences: AWSJSON!
  updatedAt: String!
}

input UpdateUserPreferencesInput {
  preferences: AWSJSON!
}

# Queries
type Query {
  # Health check endpoint
  health: String!
    @aws_oidc

  # List user's chats sorted by most recently updated
  listChats(limit: Int, nextToken: String): ChatListResult!
    @aws_oidc

  # Get a single chat with its messages
  getChat(chatId: String!, messageLimit: Int, messageNextToken: String): ChatDetail
    @aws_oidc

  # Get current user's preferences
  getUserPreferences: UserPreferences!
    @aws_oidc
}

# Mutations
type Mutation {
  # Send a message to an LLM provider - triggers streaming via subscription
  sendMessage(input: SendMessageInput!): SendMessageResponse!
    @aws_oidc

  # Internal mutation called by Lambda to publish chunks to subscribers
  # Uses IAM auth so only the Lambda function can call this
  publishChunk(
    requestId: String!
    userId: String!
    chunk: String!
    done: Boolean!
    sequence: Int!
    error: String
  ): MessageChunk!
    @aws_iam

  # Judge a response quality
  judgeResponse(input: JudgeInput!): JudgeResponse!
    @aws_oidc

  # Ask a follow-up question to a judge about their rating
  judgeFollowUp(input: JudgeFollowUpInput!): JudgeFollowUpResponse!
    @aws_oidc

  # Create a new chat
  createChat(input: CreateChatInput!): ChatSummary!
    @aws_oidc

  # Update chat metadata (title, provider)
  updateChat(input: UpdateChatInput!): ChatSummary!
    @aws_oidc

  # Delete a chat and all its messages
  deleteChat(chatId: String!): DeleteChatResult!
    @aws_oidc

  # Save a message to a chat
  saveMessage(input: SaveMessageInput!): StoredMessage!
    @aws_oidc

  # Update an existing message (content or judge ratings)
  updateMessage(input: UpdateMessageInput!): StoredMessage!
    @aws_oidc

  # Delete a message from a chat
  deleteMessage(input: DeleteMessageInput!): DeleteMessageResult!
    @aws_oidc

  # Update current user's preferences
  updateUserPreferences(input: UpdateUserPreferencesInput!): UserPreferences!
    @aws_oidc

  # Transcribe audio to text via Whisper
  transcribeAudio(input: TranscribeAudioInput!): TranscriptionResult!
    @aws_oidc
}

# Subscriptions
type Subscription {
  # Subscribe to message chunks for a specific request
  # userId filter prevents eavesdropping - only the requesting user receives chunks
  onMessageChunk(requestId: String!, userId: String!): MessageChunk
    @aws_subscribe(mutations: ["publishChunk"])
    @aws_oidc
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
